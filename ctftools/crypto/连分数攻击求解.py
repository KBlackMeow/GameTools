def continued_fractio(a,b,x=[]):
    x.append(a//b)
    if a%b==0:
        return x
    return continued_fractio(b,a%b,x)



def cal(x,i,dep):
    if i < dep-1:
        aa,bb = cal(x,i+1,dep)
        return bb,x[i]*bb + aa
    else :
        return 1,x[i]
    
a=57151226308943374680142794982010176222497765364529380268548935165758040222145627036162260994342075324103526381857344279597704799540499130349950141943084507238275546451525219742274348170961951271067509868049500661139141637437970076445350150361548157732135685521193407513224070010354999388515169624741885677283306163909232161839
b=73327580327096363941184067076642123092520041405188442426515332851631548126961330943581818271126533401554180409968250088293241154125851089420726951106005516975653246248683570268351209255797480904614659468070562106048405454014895560596358058182901059878034793142208932022564549017033260867300211774028771035453 
x = continued_fractio(a,b)

## aes 解密
for i in range(60):
    xx,yy = cal(x,0,i+1)
    print(f"x {len(bin(xx))}={xx} , y {len(bin(yy))}={yy}")
def pad(key):
    return key+(16-len(key))*b'\x00'
key = 802055116687584857500947940756
c=b'\xfa\xf5g6\xee\r\xb1\x8c\xefz\xf2U~\xe8\x7fp\x10\xdc\xaf\xf6\xc6;\x11#\xd4\xf6\xf0\xd2\x89\xe4]\xe0\xefRp\xfe\x05.\xb9\xfb\x8e\xa3j\xeb+\xf9\x03\xaa'
from Crypto.Util.number import *
from Crypto.Cipher import AES
cipher=AES.new(pad(long_to_bytes(key)),AES.MODE_ECB)
den_text = cipher.decrypt(c) # 解密密文  
print(den_text) 


